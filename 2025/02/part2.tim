// read the input file into the buffer
list[char] buffer
read_file("2025/02/input_files/input", buffer)
//read_file("2025/02/input_files/test1", buffer)

// print the content to console
println("stuff in the input file (size: {buffer.size()})")
for u64 index = 0; index < buffer.size(); index++:
    print(buffer.get(index))

// store the numbers in several lists, min/max
list[u64] min
list[u64] max
u64 value = 0
for u64 index = 0; index < buffer.size(); index++:
    // get the character and process accordingly
    char c = buffer.get(index)
    if c == '-':
        min.add(value)
        value = 0
    else if c == ',':
        max.add(value)
        value = 0
    else if c == (char)0xa:  // TODO: '\n'
    else:
        value = value * 10
        value = value + (u64)(c - '0')
// also add the last one
max.add(value)
value = 0

println("length of min: {min.size()} and max: {max.size()}")

// print the values for reference
for u64 index = 0; index < min.size(); index++:
    print("{min.get(index)}-{max.get(index)},")
println("")

u8 num_decimals(u64 value):
    u8 decimals = 0
    while value > 0:
        decimals = decimals + 1
        value = value / 10
    return decimals

bool even(u8 value):
    return (u1)(value == value / 2 * 2)

u64 get_start_value(u8 decimals):
    // get the lowest value with the decimals, e.g. 3 -> 100
    u64 value = 1
    for u8 d = 0; d < decimals-1; d++:
        value = value * 10
    return value

u64 get_end_value(u8 decimals):
    // get the highest value with the decimals, e.g. 3 -> 1000-1 -> 999
    u64 value = 1
    for u8 d = 0; d < decimals; d++:
        value = value * 10
    return value-1

u64 construct(u8 decimals, u8 target_decimals, u64 value_part, u64 min_value, u64 max_value):
    u64 mul_factor = get_start_value(decimals) * 10
    u8 num_copies = target_decimals / decimals - 1
    u64 value = value_part
    for u8 copy = 0; copy < num_copies; copy++:
        value = value * mul_factor
        value = value + value_part
    if value >= min_value && value <= max_value:
        return value
    return 0

// TODO: fix
//void add_single_result(list[u64] single_results, u64 value):
//    // adds a value to the single results, unless it's already in
//    for u64 index = 0; index < single_results.size(); index++:
//        if value == single_results.get(index):
//            return
//    print("{constructed_value_min},")
//    single_results.add(value)

list[u64] results
// loop through all values in the list
for u64 index = 0; index < min.size(); index++:
    u64 min_value = min.get(index)
    u64 max_value = max.get(index)
    println("{min_value} - {max_value}")
    // get the number of decimals
    u8 min_decimals = num_decimals(min.get(index))
    u8 max_decimals = num_decimals(max.get(index))
    u8 num_decimals_to_process
    if min_decimals <= max_decimals:
        num_decimals_to_process = max_decimals/2
    else:
        num_decimals_to_process = min_decimals/2
    
    // naively force all digits and all values
    list[u64] single_results
    for u8 decimals = 1; decimals <= num_decimals_to_process; decimals++:
        //println("decimals: {decimals}, num_decimals_to_process: {num_decimals_to_process}")
        //print("results: ")

        u64 start_value = get_start_value(decimals)
        u64 end_value = get_end_value(decimals)
        for u64 value_part = start_value; value_part <= end_value; value_part++:
            u64 constructed_value_min = construct(decimals, min_decimals, value_part, min_value, max_value)
            u64 constructed_value_max = construct(decimals, max_decimals, value_part, min_value, max_value)
            
            if constructed_value_min == constructed_value_max && constructed_value_min:
                // both are the same, and not 0, add only a single
                bool add = true
                for u64 index = 0; index < single_results.size(); index++:
                    if constructed_value_min == single_results.get(index):
                        add = false
                if add:
                    //print("{constructed_value_min},")
                    single_results.add(constructed_value_min)
            else:
                if constructed_value_min:
                    bool add = true
                    for u64 index = 0; index < single_results.size(); index++:
                        if constructed_value_min == single_results.get(index):
                            add = false
                    if add:
                        //print("{constructed_value_min},")
                        single_results.add(constructed_value_min)
                if constructed_value_max:
                    bool add = true
                    for u64 index = 0; index < single_results.size(); index++:
                        if constructed_value_max == single_results.get(index):
                            add = false
                    if add:
                        //print("{constructed_value_max},")
                        single_results.add(constructed_value_max)
        //println("")
    // copy all single_results into the results list
    for u64 index = 0; index < single_results.size(); index++:
        println("adding result: {single_results.get(index)}")
        u64 single_result = single_results.get(index)
        // it must be more than a single digit
        if single_result > 9:
            results.add(single_results.get(index))
println("solution size: {results.size()}")
u64 result = 0
for u64 index = 0; index < results.size(); index++:
    result = result + results.get(index)
println("[solution] result: {result}")

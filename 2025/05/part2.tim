// read the input file into the buffer
list[char] buffer
read_file("2025/05/input_files/input", buffer)
//read_file("2025/05/input_files/test1", buffer)
//read_file("2025/05/input_files/test2", buffer)

// print the content to console
println("stuff in the input file (size: {buffer.size()})")
for u64 index = 0; index < buffer.size(); index++:
    //print(buffer.get(index))

u64 get_int(char c):
    return (u64)(c - '0')

// parse the input
char NEWLINE = (char)0xa  // '\n'
u64 buffer_size = buffer.size()
list[u64] min_fresh_ids
list[u64] max_fresh_ids
u64 index = 0
u64 value = 0
while index < buffer_size:
    // first parse the min_fresh_id
    value = 0
    while buffer.get(index) != '-':
        value = value * 10
        value = value + get_int(buffer.get(index))
        index++
    min_fresh_ids.add(value)
    // consume the '-'
    index++
    // first parse the max_fresh_id
    value = 0
    while buffer.get(index) != NEWLINE:
        value = value * 10
        value = value + get_int(buffer.get(index))
        index++
    max_fresh_ids.add(value)
    // consume the '\n'
    index++
    // check if the next line char is also a '\n'
    if buffer.get(index) == NEWLINE:
        // stop parsing, as we have parsed all the ranges
        index = buffer_size

// print the parsed input
println("num min_fresh_ids: {min_fresh_ids.size()}, num max_fresh_ids: {max_fresh_ids.size()}")
for u64 index = 0; index < min_fresh_ids.size(); index++:
    //println("min: {min_fresh_ids.get(index)}, max: {max_fresh_ids.get(index)}")

// deduplicate the min/max fresh ids ranges by checking overlap
list[u64] dd_min_fresh
list[u64] dd_max_fresh
// loop through all fresh_ids
for u64 check_index = 0; check_index < min_fresh_ids.size(); check_index++:
    // get the current fresh_id and put it in a new list to extract duplicates
    bool run = true
    list[u64] min_to_check
    list[u64] max_to_check
    min_to_check.add(min_fresh_ids.get(check_index))
    max_to_check.add(max_fresh_ids.get(check_index))
    while run:
        bool stop_outer = false
        // loop through all min/max to check values and see if they overlap
        for u64 min_max_index = 0; !stop_outer; min_max_index++:
            u64 min_value = min_to_check.get(min_max_index)
            u64 max_value = max_to_check.get(min_max_index)
            u64 dd_index = 0
            bool stop_inner = false

            // check if there are no more dd indexes to process
            if dd_index >= dd_min_fresh.size():
                stop_outer = true
                stop_inner = true
                // add the value to the dd ranges
                dd_min_fresh.add(min_value)
                dd_max_fresh.add(max_value)
                // remove it from the to check value
                min_to_check.del(min_max_index)
                max_to_check.del(min_max_index)

            // loop through all the current deduplicated min/max fresh ids ranges
            while !stop_inner:
                u64 dd_min_fresh_value = dd_min_fresh.get(dd_index)
                u64 dd_max_fresh_value = dd_max_fresh.get(dd_index)
                // check for partial or full overlap, or outside
                if dd_min_fresh_value > max_value || dd_max_fresh_value < min_value:
                    // outside, nothing to do here
                    //println("outside")
                else if dd_min_fresh_value <= min_value && dd_max_fresh_value >= max_value:
                    // fully inside the range, so can be ignored
                    //println("inside")
                    min_to_check.del(min_max_index)
                    max_to_check.del(min_max_index)
                    // restart the checking
                    stop_outer = true
                    stop_inner = true
                else if min_value >= dd_min_fresh_value && min_value <= dd_max_fresh_value:
                    // min is inside, update the min to just outside the dd max
                    //println("min inside")
                    min_to_check.del(min_max_index)
                    min_to_check.insert(min_max_index, dd_max_fresh_value + 1)
                    // restart the checking
                    stop_outer = true
                    stop_inner = true
                else if max_value >= dd_min_fresh_value && max_value <= dd_max_fresh_value:
                    // max is inside, update the max to just outside the dd min
                    //println("max inside")
                    max_to_check.del(min_max_index)
                    max_to_check.insert(min_max_index, dd_min_fresh_value - 1)
                    // restart the checking
                    stop_outer = true
                    stop_inner = true
                else if min_value < dd_min_fresh_value && max_value > dd_max_fresh_value:
                    // outside of the range, add two new ranges to check and remove value
                    //println("fully encapsulate")
                    min_to_check.add(min_value)
                    max_to_check.add(dd_min_fresh_value - 1)
                    min_to_check.add(dd_max_fresh_value + 1)
                    max_to_check.add(max_value)
                    min_to_check.del(min_max_index)
                    max_to_check.del(min_max_index)
                    // restart the checking
                    stop_outer = true
                    stop_inner = true
                else:
                    // not in the above checks, we have an internal software error!
                    while true:
                        // this is something like abort() or exit(1)..
                        println("FAILURE!")  // TODO: add abort/exit/panic

                // check that we're out of dd indexes to check, then stop the inner loop
                dd_index++
                if (u1)(dd_index >= dd_min_fresh.size()) && !stop_outer:
                    stop_outer = true
                    stop_inner = true
                    // add the value to the dd ranges
                    dd_min_fresh.add(min_value)
                    dd_max_fresh.add(max_value)
                    // remove it from the to check value
                    min_to_check.del(min_max_index)
                    max_to_check.del(min_max_index)

            // check if we're at the last index, then stop this loop
            if (u1)(min_max_index >= min_to_check.size()) && !stop_outer:  // TODO: fix type checking here
                stop_outer = true
                // add the value to the dd ranges
                dd_min_fresh.add(min_value)
                dd_max_fresh.add(max_value)
                // remove it from the to check value
                min_to_check.del(min_max_index)
                max_to_check.del(min_max_index)

        // if we're out of values to check, we can stop running
        if min_to_check.size() == 0:
            run = false

// calculate the total number of fresh ingredients of the deduplicated ranges
u64 fresh_ingredients = 0
println("num dd_min_fresh: {dd_min_fresh.size()}, num dd_max_fresh: {dd_max_fresh.size()}")
for u64 index = 0; index < dd_min_fresh.size(); index++:
    u64 min_value = dd_min_fresh.get(index)
    u64 max_value = dd_max_fresh.get(index)
    //println("min: {min_value}, max: {max_value}")
    // include both ends of the range in the fresh ingredients
    fresh_ingredients = fresh_ingredients + (max_value - min_value + 1)

println("[solution] total number of fresh ingredients in the ranges: {fresh_ingredients}")

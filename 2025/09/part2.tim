// read the input file into the buffer
list[char] buffer
read_file("2025/09/input_files/input", buffer)
//read_file("2025/09/input_files/test1", buffer)

// print the content to console
u64 buffer_size = buffer.size()
println("stuff in the input file (size: {buffer_size})")
for u64 index = 0; index < buffer_size; index++:
    print(buffer.get(index))

// TODO: enum maybe?
u8 HORIZONTAL = 1
u8 VERTICAL = 2
u8 UP = 3
u8 DOWN = 4

u64 get_int(char c):
    return (u64)(c - '0')

u64 get_min(u64 v1, u64 v2):
    if v1 < v2:
        return v1
    return v2

u64 get_max(u64 v1, u64 v2):
    if v1 > v2:
        return v1
    return v2

u64 get_area(u64 x1, u64 y1, u64 x2, u64 y2):
    // get the length of both edges of the two points of the rectangle
    s64 dx = (s64)x1 - (s64)x2
    s64 dy = (s64)y1 - (s64)y2

    // make sure they are positive
    if dx < 0:
        dx = -dx
    if dy < 0:
        dy = -dy

    // return the area including the points
    return (u64)((dx+1) * (dy+1))

// store the list of points
list[u64] px
list[u64] py

// parse the input into the lists above
u64 index = 0
u64 value = 0
char c = (char)0
while index < buffer_size:  // TODO: make invalid list operations crash
    // first match the x coordinate
    value = 0
    c = buffer.get(index)
    while c != ',':
        value = value * 10
        value = value + get_int(c)
        index++
        c = buffer.get(index)
    px.add(value)
    index++

    // next match the y coordinate
    value = 0
    c = buffer.get(index)
    while c != (char)0xa:
        value = value * 10
        value = value + get_int(c)
        index++
        c = buffer.get(index)
    py.add(value)
    index++

// print the input
u64 num_points = px.size()
println("size x: {px.size()}, size y: {py.size()}")
for u64 index = 0; index < num_points; index++:
    println("{px.get(index)},{py.get(index)}")

// because the list loops around, we sneakly add the first item to the back
px.add(px.get(0))
py.add(py.get(0))

// for this problem we use a ray casting algorithm, and see if the whole rectangle is inside the polygon

// calculate xmin/xmax between which we cast the ray
u64 xmin = px.get(0)
u64 xmax = px.get(0)
for u64 index = 1; index < px.size(); index++:
    value = px.get(index)
    if value < xmin:
        xmin = value
    if value > xmax:
        xmax = value
u64 ray_xmin = xmin - 1
u64 ray_xmax = xmax + 1
println("x: [{xmin}, {xmax}], ray casting x: [{ray_xmin}, {ray_xmax}]")
// calculate ymin/ymax between which we cast the ray
u64 ymin = py.get(0)
u64 ymax = py.get(0)
for u64 index = 1; index < py.size(); index++:
    value = py.get(index)
    if value < ymin:
        ymin = value
    if value > ymax:
        ymax = value
u64 ray_ymin = ymin - 1
u64 ray_ymax = ymax + 1
println("y: [{ymin}, {ymax}], ray casting y: [{ray_ymin}, {ray_ymax}]")

// create a list of all edges of the polygon
list[u64] line_xstart
list[u64] line_xend
list[u64] line_ystart
list[u64] line_yend
list[u8] line_direction  // HORIZONTAL / VERTICAL
list[u8] line_value  // value going UP / DOWN
for u64 index = 0; index < num_points; index++:
    // extract the line segment
    u64 x1 = px.get(index)
    u64 x2 = px.get(index+1)
    u64 y1 = py.get(index)
    u64 y2 = py.get(index+1)
    
    // set the start and end (always in increasing value for ease of use)
    u64 xmin = get_min(x1, x2)
    line_xstart.add(xmin)
    u64 xmax = get_max(x1, x2)
    line_xend.add(xmax)
    u64 ymin = get_min(y1, y2)
    line_ystart.add(ymin)
    u64 ymax = get_max(y1, y2)
    line_yend.add(ymax)

    // set the line_direction
    if x1 == x2:  // -> changes in y
        line_direction.add(VERTICAL)
    else if y1 == y2:  // -> changes in x
        line_direction.add(HORIZONTAL)
    else:
        while true:
            println("invalid input!")

    // set the line_value
    if x1 < x2 || y1 < y2:
        line_value.add(UP)
    else:
        line_value.add(DOWN)

// print the constructed line segments
print("sizes: line_xstart: {line_xstart.size()} line_xend: {line_xend.size()}")
print(" line_ystart: {line_ystart.size()} line_yend: {line_yend.size()}")
println(" line_direction: {line_direction.size()} line_value: {line_value.size()}")
for u64 index = 0; index < num_points; index++:
    print("from: [{line_xstart.get(index)}, {line_ystart.get(index)}]")
    print(" to: [{line_xend.get(index)}, {line_yend.get(index)}]")
    if line_direction.get(index) == HORIZONTAL:
        print(" horizontal")
    else:
        print(" vertical")
    print(" going")
    if line_value.get(index) == UP:
        println(" up")
    else:
        println(" down")

// create a list of horizontal/vertical lines in increasing value with index pointers to the list above
list[u64] horizontal_indexes
list[u64] vertical_indexes
for u64 index = 0; index < num_points; index++:
    if line_direction.get(index) == HORIZONTAL:
        // add to the sorted horizontal list
        u64 y = line_ystart.get(index)
        bool added = false
        for u64 subindex = 0; !added && (bool)(subindex < horizontal_indexes.size()); subindex++:
            if y < line_ystart.get(horizontal_indexes.get(subindex)):
                added = true
                horizontal_indexes.insert(subindex, index)
        if !added:
            horizontal_indexes.add(index)
    else:  // VERTICAL
        // add to the sorted vertical list
        u64 x = line_xstart.get(index)
        bool added = false
        for u64 subindex = 0; !added && (bool)(subindex < vertical_indexes.size()); subindex++:
            if x < line_xstart.get(vertical_indexes.get(subindex)):
                added = true
                vertical_indexes.insert(subindex, index)
        if !added:
            vertical_indexes.add(index)

// print the sorted lines
for u64 subindex = 0; subindex < horizontal_indexes.size(); subindex++:
    u64 index = horizontal_indexes.get(subindex)
    print("i={index} line at y={line_ystart.get(index)},")
    println(" between [{line_xstart.get(index)}, {line_xend.get(index)}]")
for u64 subindex = 0; subindex < vertical_indexes.size(); subindex++:
    u64 index = vertical_indexes.get(subindex)
    print("i={index} line at x={line_xstart.get(index)},")
    println(" between [{line_ystart.get(index)}, {line_yend.get(index)}]")

bool process_line(list[u64] line_start_list, list[u64] line_intersect_start, list[u64] line_intersect_end, list[u64] indexes, list[u8] line_value, u64 line, u64 ray_min, u64 ray_max, u64 line_min, u64 line_max):
    // build a list of intersecting lines
    list[u64] intersecting_line
    for u64 subindex = 0; subindex < indexes.size(); subindex++:
        u64 index = indexes.get(subindex)
        u64 start = line_intersect_start.get(index)
        u64 end = line_intersect_end.get(index)
        if start <= line && line <= end:
            intersecting_line.add(index)

    // loop through the intersecting lines creating enter-exit events
    list[u64] enter_exit
    list[bool] enter
    bool outside = true
    for u64 subindex = 0; subindex < intersecting_line.size(); subindex++:
        u64 index = intersecting_line.get(subindex)
        u64 start = line_intersect_start.get(index)
        u64 end = line_intersect_end.get(index)
        u64 line_start = line_start_list.get(index)
        u8 current_value = line_value.get(index)

        // create a toggle event
        if start < line && line < end:
            enter_exit.add(line_start)
            enter.add(outside)
            outside = !outside

        // check if we end on the points
        if start == line || line == end:
            if outside:
                // check that the next u64  moves in the same direction
                // then we enter at this point and don't leave
                subindex++  // consume the next point
                u64 next_index = intersecting_line.get(subindex)
                u8 next_value = line_value.get(next_index)
                u64 next_line = line_start_list.get(next_index)
                if current_value == next_value:
                    // create entry event
                    enter_exit.add(line_start)
                    enter.add(true)
                    outside = false
                else:
                    // otherwise we enter at this point and leave at the next
                    // create entry event
                    enter_exit.add(line_start)
                    enter.add(true)
                    // create exit event
                    enter_exit.add(next_line)
                    enter.add(false)
            else:  // inside
                // check that the next u64  moves in the same direction
                // then we're still inside at this point and leave at the next
                subindex++  // consume the next point
                u64 next_index = intersecting_line.get(subindex)
                u8 next_value = line_value.get(next_index)
                u64 next_line = line_start_list.get(next_index)
                if current_value == next_value:
                    // create exit event
                    enter_exit.add(next_line)
                    enter.add(false)
                    outside = true
                else:
                    // nothing needs to happen, we're still inside

    // quickly return if the line start value is before the first enter_exit event
    if line_min < enter_exit.get(0):
        return true

    u64 enter_exit_index = 0
    bool inside = false
    u64 start_pos = enter_exit.get(0)
    // perform the ray trace with the enter and exit events
    for u64 current_pos = start_pos; current_pos < line_max; current_pos++:
        // process enter and exit events
        if current_pos == enter_exit.get(enter_exit_index):
            if enter.get(enter_exit_index):
                // process enter event
                inside = true
                enter_exit_index++
            else:
                inside = false
                enter_exit_index++
            // when we're out of events, we can also return
            if enter_exit_index == enter_exit.size():
                return !inside

        // check if we're on the line, but outside
        if (bool)(line_min <= current_pos) && !inside:
            return true

    return false

// find the largest rectangle in the points
u64 largest_area = 0
for u64 index1 = 0; index1 < num_points; index1++:
    println("processing start-index: [ {index1+1} / {num_points} ]")
    for u64 index2 = index1+1; index2 < num_points; index2++:
        // extract the line segment x and y values
        u64 x1 = px.get(index1)
        u64 y1 = py.get(index1)
        u64 x2 = px.get(index2)
        u64 y2 = py.get(index2)

        // get the min/max values from them
        u64 xmin = get_min(x1, x2)
        u64 xmax = get_max(x1, x2)
        u64 ymin = get_min(y1, y2)
        u64 ymax = get_max(y1, y2)

        // calculate the area, and don't even process the rectangle if the area is less than largest_area
        u64 area = get_area(x1, y1, x2, y2)
        if area > largest_area:
            // only if the whole rectangle is inside, check its area
            bool failure = false

            if !failure:
                failure = process_line(line_ystart, line_xstart, line_xend, horizontal_indexes, line_value, xmin, ray_ymin, ray_ymax, ymin, ymax)

            if !failure:
                failure = process_line(line_ystart, line_xstart, line_xend, horizontal_indexes, line_value, xmax, ray_ymin, ray_ymax, ymin, ymax)

            if !failure:
                failure = process_line(line_xstart, line_ystart, line_yend, vertical_indexes, line_value, ymin, ray_xmin, ray_xmax, xmin, xmax)

            if !failure:
                failure = process_line(line_xstart, line_ystart, line_yend, vertical_indexes, line_value, ymax, ray_xmin, ray_xmax, xmin, xmax)

            if !failure:
                if area > largest_area:
                    println("largest area: {largest_area} -> {area}")
                    largest_area = area

println("[solution] largest area of any rectangle using only red and green tiles: {largest_area}")

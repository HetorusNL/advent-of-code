// read the input file into the buffer
list[char] buffer
read_file("2025/08/input_files/input", buffer)
//read_file("2025/08/input_files/test1", buffer)

u64 NUM_CONNECTIONS = 1000
u64 NUM_LARGEST_CIRCUITS = 3

// print the content to console
u64 buffer_size = buffer.size()
println("stuff in the input file (size: {buffer_size})")
//for u64 index = 0; index < buffer_size; index++:
//    print(buffer.get(index))

// TODO: implement this:
//class Point3D:
//    s32 x
//    s32 y
//    s32 z
//list[Point3D] points

u64 get_int(char c):
    return (u64)(c - '0')

// we don't support sqrt() and using squared distance instead of distance doesn't change sorting order :D
u64 squared_euclidean_distance(u64 x1, u64 y1, u64 z1, u64 x2, u64 y2, u64 z2):
    u64 x_squared = (x1 - x2) * (x1 - x2)
    u64 y_squared = (y1 - y2) * (y1 - y2)
    u64 z_squared = (z1 - z2) * (z1 - z2)
    return x_squared + y_squared + z_squared

// store the list of points, and keep the circuit id if it's connected to a circuit (-1 is not)
list[u64] px
list[u64] py
list[u64] pz
list[s64] circuit

// parse the input into the lists above
u64 index = 0
u64 value = 0
char c = (char)0
while index < buffer_size:  // TODO: make invalid list operations crash
    // first match the x coordinate
    value = 0
    c = buffer.get(index)
    while c != ',':
        value = value * 10
        value = value + get_int(c)
        index++
        c = buffer.get(index)
    px.add(value)
    index++

    // next match the y coordinate
    value = 0
    c = buffer.get(index)
    while c != ',':
        value = value * 10
        value = value + get_int(c)
        index++
        c = buffer.get(index)
    py.add(value)
    index++

    // end with the z coordinate
    value = 0
    c = buffer.get(index)
    while c != (char)0xa:
        value = value * 10
        value = value + get_int(c)
        index++
        c = buffer.get(index)
    pz.add(value)
    circuit.add(-1)
    index++

// print the input
u64 num_points = px.size()
println("size x: {px.size()}, size y: {py.size()}, size z: {pz.size()}, circuit: {circuit.size()}")
//for u64 index = 0; index < num_points; index++:
//    println("{px.get(index)},{py.get(index)},{pz.get(index)},{circuit.get(index)}")

// create lists that have from-to-distance information
list[u64] index_from
list[u64] index_to
list[u64] distance
for u64 from_index = 0; from_index < num_points; from_index++:
    u64 from_x = px.get(from_index)
    u64 from_y = py.get(from_index)
    u64 from_z = pz.get(from_index)
    //println(from_index)
    for u64 to_index = from_index+1; to_index < num_points; to_index++:
        //println("to {to_index}")
        u64 to_x = px.get(to_index)
        u64 to_y = py.get(to_index)
        u64 to_z = pz.get(to_index)
        // TODO: this should show e.g. 'error: distance already defined', or something
        // with the list and function both called 'distance'
        //distance.add(distance(from_x, from_y, from_z, to_x, to_y, to_z))
        // TODO: this should compile
        //distance.add(squared_euclidean_distance(from_x, from_y, from_z, to_x, to_y, to_z))
        u64 squared_distance = squared_euclidean_distance(from_x, from_y, from_z, to_x, to_y, to_z)
        // add the distance sorted from low to high in the list
        u64 distance_size = distance.size()
        bool stop = false
        bool should_add = true
        for u64 distance_index = 0; !stop && (u1)(distance_index < distance_size); distance_index++:
            u64 d = distance.get(distance_index)
            if distance_index > NUM_CONNECTIONS:
                should_add = false
                stop = true
            else if squared_distance < d:
                // smaller distance, add in front here
                index_from.insert(distance_index, from_index)
                index_to.insert(distance_index, to_index)
                distance.insert(distance_index, squared_distance)
                stop = true
        if !stop && should_add:
            index_from.add(from_index)
            index_to.add(to_index)
            distance.add(squared_distance)

println("size from: {index_from.size()}, size to: {index_to.size()}, size distance: {distance.size()}")
//for u64 distance_index = 0; distance_index < distance.size(); distance_index++:
//    println(distance.get(distance_index))

// perform the first NUM_CONNECTIONS shortest connections
s64 max_circuit_id = -1
for u64 distance_index = 0; distance_index < NUM_CONNECTIONS; distance_index++:
    u64 p1_index = index_from.get(distance_index)
    u64 p2_index = index_to.get(distance_index)
    //println("point 1: {px.get(p1_index)},{py.get(p1_index)},{pz.get(p1_index)},{circuit.get(p1_index)}")
    //println("point 2: {px.get(p2_index)},{py.get(p2_index)},{pz.get(p2_index)},{circuit.get(p2_index)}")
    
    // get the circuit id from both points
    s64 c1 = circuit.get(p1_index)
    s64 c2 = circuit.get(p2_index)

    // if both are not connected, add a new circuit with the specified id
    if c1 == -1 && c2 == -1:
        max_circuit_id++
        circuit.del(p1_index)
        circuit.insert(p1_index, max_circuit_id)
        circuit.del(p2_index)
        circuit.insert(p2_index, max_circuit_id)
    else if c1 == -1:
        // only c1 is unconnected, connect to c2
        circuit.del(p1_index)
        circuit.insert(p1_index, c2)
    else if c2 == -1:
        // only c2 is unconnected, connect to c1
        circuit.del(p2_index)
        circuit.insert(p2_index, c1)
    else if c1 == c2:
        // nothing to do here, both already connected on same circuit id
    else:
        // both are connected differently, get the lowest circuit id and update all
        s64 lowest = 0
        s64 highest = 0
        if c1 < c2:
            lowest = c1
            highest = c2
        else:
            lowest = c2
            highest = c1
        // loop through all circuits, and update highest to lowest
        for u64 circuit_index = 0; circuit_index < num_points; circuit_index++:
            if circuit.get(circuit_index) == highest:
                circuit.del(circuit_index)
                circuit.insert(circuit_index, lowest)

    // calculate the connections per circuit
    for s64 circuit_id = 0; circuit_id < max_circuit_id+1; circuit_id++:
        u64 connections = 0
        for s64 point_circuit = 0; point_circuit < (s64)num_points; point_circuit++:
            if circuit.get(point_circuit) == circuit_id:
                connections++
        //println("{circuit_id}: connections: {connections}")

// create a list, sorted by amount of connections, decreasing
list[u64] connections
// calculate the connections per circuit
for s64 circuit_id = 0; circuit_id < max_circuit_id+1; circuit_id++:
    u64 num_connections = 0
    for s64 point_circuit = 0; point_circuit < (s64)num_points; point_circuit++:
        if circuit.get(point_circuit) == circuit_id:
            num_connections++
    //println("{circuit_id}: num_connections: {num_connections}")
    bool added = false
    for u64 connections_index = 0; !added && (u1)(connections_index < connections.size()); connections_index++:
        u64 conn = connections.get(connections_index)
        if num_connections > conn:
            // more connections, add in front here
            connections.insert(connections_index, num_connections)
            added = true
    if !added:
        connections.add(num_connections)

// multiply the highest NUM_LARGEST_CIRCUITS connections together
u64 result = 1
for u64 connections_index = 0; connections_index < NUM_LARGEST_CIRCUITS; connections_index++:
    value = connections.get(connections_index)
    println(value)
    result = result * value

println("[solution] the largest {NUM_LARGEST_CIRCUITS} circuit sizes multiplied togeter: {result}")

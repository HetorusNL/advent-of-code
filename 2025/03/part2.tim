// read the input file into the buffer
list[char] buffer
read_file("2025/03/input_files/input", buffer)
//read_file("2025/03/input_files/test1", buffer)

// print the content to console
println("stuff in the input file (size: {buffer.size()})")
for u64 index = 0; index < buffer.size(); index++:
    print(buffer.get(index))

// count the rows and columns, and create a list of values without newline
u8 rows = 0
u8 cols = 0
bool run = true
for u64 index = 0; run; index++:
    if buffer.get(index) == '\n':
        run = false
        cols = (u8)(index)
        rows = (u8)(buffer.size() / (index+1))
list[u8] batteries
for u8 row = 0; row < rows; row++:
    for u8 col = 0; col < cols; col++:
        batteries.add(buffer.get(row*(cols+1)+col) - '0')
println("rows: {rows}, cols: {cols}")

// print the input
for u8 row = 0; row < rows; row++:
    for u8 col = 0; col < cols; col++:
        print(batteries.get(row*cols + col))
    println("")

// loop through the battery banks
u64 total_joltage = 0
u8 NUM_BATTERIES = 12
for u8 row = 0; row < rows; row++:
    u64 row_max_joltage = 0
    u8 start_col = 0
    for u8 col_number = 0; col_number < NUM_BATTERIES; col_number++:
        // get the maximum value between start_col and cols+col_number-NUM_BATTERIES
        u8 row_highest_joltage_value = 0
        u8 row_highest_joltage_index = 0
        for u8 col = start_col; col < cols-NUM_BATTERIES+col_number+1; col++:
            u8 this_joltage = batteries.get(row*cols + col)
            if this_joltage > row_highest_joltage_value:
                row_highest_joltage_value = this_joltage
                row_highest_joltage_index = col
        // update start_col and the row_max_joltage
        start_col = row_highest_joltage_index+1
        row_max_joltage = row_max_joltage * 10
        row_max_joltage += (u64)row_highest_joltage_value

    total_joltage += (u64)row_max_joltage
    println(row_max_joltage)
println("[solution] total joltage: {total_joltage}")

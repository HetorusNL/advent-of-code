// read the input file into the buffer
list[char] buffer
read_file("2025/01/input_files/input", buffer)
//read_file("2025/01/input_files/test1", buffer)

// print the content to console
println("stuff in the input file (size: {buffer.size()})")
//for u64 index = 0; index < buffer.size(); index++:
//    print(buffer.get(index))

// convert the list from chars to two lists with rotation and value
list[char] rotations
list[u16] values
u64 index = 0
while index < buffer.size():
    // first a rotation
    rotations.add(buffer.get(index))  // TODO: with this 'rotation', internal compiler error
    index++
    // then a value
    u16 value = 0
    // TODO: &&, make char and base/u16 be used together
    while (u16)((buffer.get(index) >= '0') + (buffer.get(index) <= '9')) == 2:
        value = value * 10  // TODO: *=
        value = value + (u16)(buffer.get(index) - '0')  // TODO: +=
        // TODO: line numbers off by one
        index++
    values.add(value)
    // skip the newline
    index++

println("there are {rotations.size()} rotations in the input")
//for u64 index = 0; index < rotations.size(); index++:
//    print(rotations.get(index))
//    println(values.get(index))

// perform the rotations
s32 value = 50
u16 zero_rotations = 0
for u64 index = 0; index < rotations.size(); index++:
    // add the value
    if rotations.get(index) == 'L':
        value = value - (s32)values.get(index)
    else:  // 'R'
        value = value + (s32)values.get(index)

    // perform modulo 100
    while value < 0:
        value = value + 100
    while value > 99:
        value = value - 100
    //println("value after {index} = {value}")

    // check if it's zero
    if value == 0:
        zero_rotations = zero_rotations + 1
    
// print the result
println("the number of rotations that end in zero are: {zero_rotations}")

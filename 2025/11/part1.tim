// read the input file into the buffer
list[char] buffer
read_file("2025/11/input_files/input", buffer)
//read_file("2025/11/input_files/test1", buffer)

// print the content to console
u64 buffer_size = buffer.size()
println("stuff in the input file (size: {buffer_size})")
for u64 index = 0; index < buffer_size; index++:
    print(buffer.get(index))

// return a number with the value of the 3 chars as value
u64 get_val(list[char] buffer, u64 index):
    u64 value = 0
    for u64 offset = 0; offset < 3; offset++:
        value = value * 256  // shift to next byte
        value = value + (u64)buffer.get(index + offset)
    return value

// check if the device is in the lut, otherwise add it at the end
// returns the id, which is simply the index of the device in the list
u64 device_id(list[u64] lut, u64 device):
    // loop through the device -> id pairs
    for u64 index = 0; index < lut.size(); index++:
        if lut.get(index) == device:
            return index

    // otherwise add the device to the end
    lut.add(device)
    return lut.size() - 1

u64 get_you_id(list[u64] lut):
    list[char] you_list
    you_list.add('y')
    you_list.add('o')
    you_list.add('u')
    return device_id(lut, get_val(you_list, 0))

u64 get_out_id(list[u64] lut):
    list[char] out_list
    out_list.add('o')
    out_list.add('u')
    out_list.add('t')
    return device_id(lut, get_val(out_list, 0))

// parse the input into several lists (poor man's hmap / list of classes)
// create a list with a device to id mapping (index)
list[u64] lut  // device -> id -> ...
u64 value = 0
for u64 index = 0; index < buffer_size;:
    // get the value
    value = get_val(buffer, index)
    // map to device id
    device_id(lut, value)

    // increment index to see separator
    index = index + 3
    char separator = buffer.get(index)
    if separator == ':':
        index = index + 2
    else:  // ' ' and '\n'
        index++

// print the list of device -> id mapping
for u64 index = 0; index < lut.size(); index++:
    println("{lut.get(index)} -> {index}")

u64 num_devices = lut.size()
list[bool] solved  // id -> bool
list[u64] connection_offset // id -> u64
list[u64] num_connections  // id -> u64
list[u64] paths_to_out  // id -> u64
// prepopulate the lists with zeros
for u64 index = 0; index < num_devices; index++:
    println("populating lut for id {index}")
    solved.add(false)
    connection_offset.add(0)
    num_connections.add(0)
    paths_to_out.add(0)

// get the list of device connections based on id and with num outputs
list[u64] connections
for u64 index = 0; index < buffer_size;:
    // get the in value
    value = get_val(buffer, index)
    // get the device id
    u64 from_id = device_id(lut, value)
    println("processing device at from_id: {from_id}")

    // add the connection offset of this device to the list
    connection_offset.set(from_id, connections.size())
    println("connection_offset: {connections.size()} ({connection_offset.get(from_id)})")

    // consume the from_id, ':' and ' '
    index = index + 5

    // keep consuming a list of connections for this device id
    bool run = true  // is false when we encounter a '\n'
    while run:
        // get the value
        value = get_val(buffer, index)
        // get the device id
        u64 to_id = device_id(lut, value)

        // add the connection to the list
        connections.add(to_id)
        println("adding connection to {to_id}")

        // increment index to see next char
        index = index + 3
        char c = buffer.get(index)
        if c == (char)0xa:  // '\n'
            // newline, add the num_connections to the list for this device
            num_connections.set(from_id, connections.size() - connection_offset.get(from_id))
            println("num_connections: {connections.size() - connection_offset.get(from_id)}")
            run = false
        index++

// print the connection_offset and num_connections
for u64 index = 0; index < num_devices; index++:
    // TODO: below statement gives compyler exception (IndexError)
    // println("id: {index}, connection_offset: {connection_offset.get(index)}, size: {num_connections.get(index)"})
    println("id: {index}, connection_offset: {connection_offset.get(index)}, size: {num_connections.get(index)}")

// get the 'you'-id and 'out'-id
u64 you_id = get_you_id(lut)
u64 out_id = get_out_id(lut)
println("you_id: {you_id}, out_id: {out_id}")

// mark all devices going to out as solved, and add paths_to_out
for u64 index = 0; index < num_devices; index++:
    if num_connections.get(index) == 1:
        if connections.get(connection_offset.get(index)) == out_id:
            println("{index} is finished")
            solved.set(index, true)
            paths_to_out.set(index, 1)

// the main loop solving the connections
// loop continuously until you is solved
while !solved.get(you_id):
    // loop through all devices
    for u64 index = 0; index < num_devices; index++:
        // check that this device is not yet solved and can be solved (has connections)
        if !solved.get(index) && (bool)(num_connections.get(index) > 0):
            // loop through the connections from this device
            u64 start_index = connection_offset.get(index)
            u64 paths = 0  // already store the solved paths, in case this is solved
            bool is_solved = true
            for u64 to_index = start_index; to_index < start_index + num_connections.get(index); to_index++:
                // get the to_device_id from the index
                u64 to_device_id = connections.get(to_index)
                // check if it is solved
                if solved.get(to_device_id):
                    paths = paths + paths_to_out.get(to_device_id)
                else:
                    is_solved = false

            // when all connections are solved, also solve this device id
            if is_solved:
                println("{index} is finished")
                solved.set(index, true)
                paths_to_out.set(index, paths)

println("[solution] paths from you to out: {paths_to_out.get(you_id)}")
